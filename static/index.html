 <!-- WEB APP (Html, CSS, JS, Python) -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exercise Analyzer</title>
    
    <!-- MediaPipe dependencies for pose detection and computer vision -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
    
    <style>
        /* Global reset and base styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Main body animated gradients */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            /* Multi-layered radial gradients for depth and visual interest */
            background: 
                radial-gradient(circle at 20% 80%, rgba(74, 144, 226, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 107, 53, 0.12) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(74, 144, 226, 0.08) 0%, transparent 50%),
                linear-gradient(135deg, #0f0f0f 0%, #1a1a1a 25%, #2d2d2d 50%, #1a1a1a 75%, #0f0f0f 100%);
            min-height: 100vh;
            padding: 10px;
            color: #e0e0e0;
            position: relative;
            overflow-x: hidden;
        }

        /* Additional background layer for enhanced visual depth */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(ellipse at 10% 30%, rgba(74, 144, 226, 0.05) 0%, transparent 40%),
                radial-gradient(ellipse at 90% 70%, rgba(255, 107, 53, 0.04) 0%, transparent 40%),
                radial-gradient(ellipse at 60% 10%, rgba(74, 144, 226, 0.03) 0%, transparent 30%);
            pointer-events: none;
            z-index: -1;
        }

        /* Main container styling */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: 
                linear-gradient(145deg, rgba(30, 30, 30, 0.98) 0%, rgba(45, 45, 45, 0.95) 50%, rgba(25, 25, 25, 0.98) 100%);
            border-radius: 20px;
            padding: 20px;
            backdrop-filter: blur(15px); /* Glassmorphism effect */
            box-shadow: 
                0 0 50px rgba(0, 0, 0, 0.8),
                0 0 100px rgba(74, 144, 226, 0.1),
                inset 0 0 20px rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(74, 144, 226, 0.2);
            position: relative;
        }

        /* Animated border glow effect for container */
        .container::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, 
                transparent, 
                rgba(74, 144, 226, 0.3) 20%, 
                transparent 40%,
                transparent 60%,
                rgba(255, 107, 53, 0.2) 80%, 
                transparent);
            border-radius: 22px;
            z-index: -1;
            animation: borderGlow 4s ease-in-out infinite alternate;
        }

        /* Keyframe animation for border glow */
        @keyframes borderGlow {
            0% { opacity: 0.3; }
            100% { opacity: 0.8; }
        }

        /* Header section styling */
        .header {
            text-align: center;
            margin-bottom: 20px;
            position: relative;
        }

        /* Main title with gradient text and glow effects */
        .header h1 {
            color: #ffffff;
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #ff6b35, #4a90e2, #ff8c42);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 
                0 0 20px rgba(255, 107, 53, 0.3),
                0 0 40px rgba(74, 144, 226, 0.2);
            filter: drop-shadow(0 0 10px rgba(255, 107, 53, 0.4));
        }

        /* Subtitle styling */
        .header p {
            color: #b0b0b0;
            font-size: 1.1rem;
            text-shadow: 0 0 10px rgba(176, 176, 176, 0.3);
        }

        /* Video container with animated border */
        .video-container {
            position: relative;
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 
                0 0 30px rgba(0, 0, 0, 0.7),
                0 0 60px rgba(74, 144, 226, 0.15);
            border: 2px solid rgba(74, 144, 226, 0.4);
            max-width: 640px; 
            margin-left: auto; 
            margin-right: auto; 
        }

        /* Animated border effect for video container */
        .video-container::before {
            content: '';
            position: absolute;
            top: -1px;
            left: -1px;
            right: -1px;
            bottom: -1px;
            background: linear-gradient(90deg, 
                rgba(74, 144, 226, 0.3), 
                rgba(255, 107, 53, 0.2), 
                rgba(74, 144, 226, 0.3));
            border-radius: 16px;
            z-index: -1;
            animation: videoBorder 3s linear infinite;
        }

        /* Animation for video border gradient */
        @keyframes videoBorder {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* Video element styling - mirrored for selfie view */
        #videoElement {
            max-width: 100%;
            height: auto;
            transform: scaleX(-1); /* Mirror the video horizontally */
        }

        /* Container for pose visualization (stickman) */
        .stickman-container {
            position: relative;
            display: flex;
            justify-content: center;
            margin-top: 20px;
            margin-bottom: 20px;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 
                0 0 30px rgba(0, 0, 0, 0.7),
                0 0 60px rgba(255, 107, 53, 0.12);
            background: 
                linear-gradient(145deg, #1a1a1a 0%, #2a2a2a 50%, #1a1a1a 100%);
            border: 2px solid rgba(255, 107, 53, 0.3);
            max-width: 640px; 
            margin-left: auto; 
            margin-right: auto; 
        }

        /* Canvas styling for pose visualization */
        .stickman-container canvas {
            width: 100%;
            height: auto;
        }

        #canvasElement {
            position: static;
            width: 100%;
            height: auto;
        }

        /* Control buttons container */
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        /* Base button styling */
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 
                0 0 20px rgba(0, 0, 0, 0.5),
                inset 0 0 20px rgba(255, 255, 255, 0.05);
            position: relative;
            overflow: hidden;
        }

        /* Shine effect for buttons */
        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .btn:hover::before {
            left: 100%;
        }

        /* Primary button variant (orange theme) */
        .btn-primary {
            background: linear-gradient(45deg, #ff6b35, #ff8c42);
            color: white;
            border: 2px solid #ff6b35;
            box-shadow: 
                0 0 20px rgba(255, 107, 53, 0.4),
                0 0 40px rgba(255, 107, 53, 0.2);
        }

        .btn-primary:hover {
            background: linear-gradient(45deg, #ff8c42, #ffab42);
            box-shadow: 
                0 0 30px rgba(255, 107, 53, 0.6),
                0 0 60px rgba(255, 107, 53, 0.3);
            transform: translateY(-2px);
        }

        /* Secondary button variant (blue theme) */
        .btn-secondary {
            background: linear-gradient(45deg, #4a90e2, #357abd);
            color: white;
            border: 2px solid #4a90e2;
            box-shadow: 
                0 0 20px rgba(74, 144, 226, 0.4),
                0 0 40px rgba(74, 144, 226, 0.2);
        }

        .btn-secondary:hover {
            background: linear-gradient(45deg, #357abd, #2968a3);
            box-shadow: 
                0 0 30px rgba(74, 144, 226, 0.6),
                0 0 60px rgba(74, 144, 226, 0.3);
            transform: translateY(-2px);
        }

        /* Disabled button state */
        .btn:disabled {
            background: linear-gradient(45deg, #3a3a3a, #2a2a2a);
            cursor: not-allowed;
            transform: none;
            color: #666666;
            border: 2px solid #444444;
            box-shadow: 
                0 0 10px rgba(0, 0, 0, 0.3),
                inset 0 0 10px rgba(0, 0, 0, 0.2);
        }

        /* Camera selection dropdown */
        .camera-selector {
            margin-bottom: 20px;
            text-align: center;
        }

        .camera-selector label {
            color: #e0e0e0;
            font-weight: 600;
            margin-right: 10px;
            text-shadow: 0 0 10px rgba(224, 224, 224, 0.3);
        }

        /* Styled select dropdown */
        .camera-selector select {
            padding: 10px 15px;
            border-radius: 10px;
            border: 2px solid rgba(74, 144, 226, 0.5);
            font-size: 1rem;
            background: linear-gradient(145deg, #2a2a2a, #3a3a3a);
            color: #e0e0e0;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 
                0 0 15px rgba(74, 144, 226, 0.2),
                inset 0 0 10px rgba(0, 0, 0, 0.3);
        }

        .camera-selector select:hover {
            border-color: rgba(255, 107, 53, 0.6);
            background: linear-gradient(145deg, #3a3a3a, #4a4a4a);
            box-shadow: 
                0 0 20px rgba(255, 107, 53, 0.3),
                inset 0 0 10px rgba(0, 0, 0, 0.2);
        }

        .camera-selector select:focus {
            outline: none;
            border-color: rgba(255, 107, 53, 0.8);
            box-shadow: 
                0 0 25px rgba(255, 107, 53, 0.4),
                inset 0 0 10px rgba(0, 0, 0, 0.2);
        }

        /* Information panel grid layout */
        .info-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        /* Individual info cards with glassmorphism effect */
        .info-card {
            background: 
                linear-gradient(145deg, rgba(35, 35, 35, 0.95) 0%, rgba(50, 50, 50, 0.9) 50%, rgba(30, 30, 30, 0.95) 100%);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 
                0 0 30px rgba(0, 0, 0, 0.5),
                0 0 60px rgba(74, 144, 226, 0.1),
                inset 0 0 20px rgba(255, 255, 255, 0.02);
            border-left: 5px solid #ff6b35; /* Color-coded left border */
            border: 1px solid rgba(74, 144, 226, 0.3);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        /* Subtle inner glow effect for cards */
        .info-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.02) 0%, transparent 70%);
            pointer-events: none;
        }

        /* Hover effects for info cards */
        .info-card:hover {
            transform: translateY(-3px);
            box-shadow: 
                0 0 40px rgba(0, 0, 0, 0.6),
                0 0 80px rgba(74, 144, 226, 0.15);
            border-color: rgba(74, 144, 226, 0.5);
        }

        /* Different color themes for each info card */
        .info-card:nth-child(2) {
            border-left-color: #4a90e2;
            box-shadow: 
                0 0 30px rgba(0, 0, 0, 0.5),
                0 0 60px rgba(74, 144, 226, 0.12);
        }

        .info-card:nth-child(3) {
            border-left-color: #ff6b35;
            box-shadow: 
                0 0 30px rgba(0, 0, 0, 0.5),
                0 0 60px rgba(255, 107, 53, 0.1);
        }

        /* Card titles */
        .info-card h3 {
            color: #ffffff;
            margin-bottom: 10px;
            font-size: 1.2rem;
            font-weight: 700;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
        }

        /* Card content text */
        .info-card p {
            color: #d0d0d0;
            margin: 5px 0;
            font-weight: 600;
            text-shadow: 0 0 8px rgba(208, 208, 208, 0.2);
        }

        /* Exercise history section title */
        .exercise-history-title {
            color: #ffffff;
            font-size: 1.1rem;
            font-weight: 700;
            margin-bottom: 10px;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
        }

        /* Exercise counter styling */
        #exerciseCounters p {
            color: #d0d0d0;
            font-weight: 600;
        }

        #exerciseCounters span {
            color: #ff6b35;
            font-weight: 700;
            text-shadow: 0 0 10px rgba(255, 107, 53, 0.5);
        }

        /* Status indicator styling */
        .status {
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 600;
            text-align: center;
            margin: 10px 0;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }

        /* Animated shimmer effect for status */
        .status::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            animation: statusShimmer 2s infinite;
        }

        @keyframes statusShimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        /* Active status variant (green) */
        .status.active {
            background: rgba(76, 175, 80, 0.2);
            color: #4caf50;
            border: 2px solid #4caf50;
            box-shadow: 
                0 0 20px rgba(76, 175, 80, 0.4),
                0 0 40px rgba(76, 175, 80, 0.2);
        }

        /* Inactive status variant (red) */
        .status.inactive {
            background: rgba(244, 67, 54, 0.2);
            color: #f44336;
            border: 2px solid #f44336;
            box-shadow: 
                0 0 15px rgba(244, 67, 54, 0.3);
        }

        /* Feedback message styling */
        .feedback {
            font-size: 1.1rem;
            font-weight: 600;
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            position: relative;
            overflow: hidden;
        }

        /* Subtle inner highlight for feedback */
        .feedback::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 30% 40%, rgba(255, 255, 255, 0.05) 0%, transparent 50%);
            pointer-events: none;
        }

        /* Correct feedback variant (green) */
        .feedback.correct {
            background: rgba(76, 175, 80, 0.2);
            color: #4caf50;
            border: 2px solid #4caf50;
            box-shadow: 
                0 0 25px rgba(76, 175, 80, 0.4),
                0 0 50px rgba(76, 175, 80, 0.2);
            text-shadow: 0 0 10px rgba(76, 175, 80, 0.6);
        }

        /* Warning feedback variant (orange) */
        .feedback.warning {
            background: rgba(255, 152, 0, 0.2);
            color: #ff9800;
            border: 2px solid #ff9800;
            box-shadow: 
                0 0 25px rgba(255, 152, 0, 0.4),
                0 0 50px rgba(255, 152, 0, 0.2);
            text-shadow: 0 0 10px rgba(255, 152, 0, 0.6);
        }

        /* Neutral feedback variant (gray) */
        .feedback.neutral {
            background: rgba(96, 125, 139, 0.2);
            color: #90a4ae;
            border: 2px solid #607d8b;
            box-shadow: 0 0 15px rgba(96, 125, 139, 0.3);
        }

        /* Current exercise display */
        #currentExercise {
            color: #4a90e2;
            font-weight: 700;
            font-size: 1.9rem;
            text-shadow: 0 0 15px rgba(74, 144, 226, 0.6);
            text-transform: uppercase;
        }

        /* Confidence level display */
        #confidence {
            color: #ff6b35;
            font-weight: 700;
            text-shadow: 0 0 15px rgba(255, 107, 53, 0.6);
        }

        /* Frame counter display */
        #frameCount {
            color: #90a4ae;
            font-weight: 600;
            text-shadow: 0 0 8px rgba(144, 164, 174, 0.4);
        }

        /* Custom scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: linear-gradient(180deg, #1a1a1a, #2a2a2a);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #ff6b35, #4a90e2);
            border-radius: 4px;
            box-shadow: 0 0 10px rgba(255, 107, 53, 0.5);
        }

        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, #4a90e2, #ff6b35);
            box-shadow: 0 0 15px rgba(74, 144, 226, 0.5);
        }

        /* Responsive design for mobile devices */
        @media (max-width: 768px) {
            .container {
                padding: 15px;
                margin: 5px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            .btn {
                padding: 10px 20px;
                font-size: 0.9rem;
                width: 200px;
            }
            
            .info-panel {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Application header with title and description -->
        <div class="header">
            <h1>AI Gym Tracker</h1>
            <p>Real-time exercise recognition and form analysis</p>
        </div>

        <!-- Camera selection dropdown -->
        <div class="camera-selector">
            <label for="cameraSelect">Select Camera: </label>
            <select id="cameraSelect">
                <option value="">Loading cameras...</option>
            </select>
        </div>

        <!-- Video feed container -->
        <div class="video-container">
            <video id="videoElement" autoplay playsinline></video>
        </div>
        
        <!-- Pose visualization canvas -->
        <div class="stickman-container">
            <canvas id="canvasElement"></canvas>
        </div>

        <!-- Control buttons for session management and recording -->
        <div class="controls">
            <button id="startBtn" class="btn btn-primary">Start Session</button>
            <button id="endBtn" class="btn btn-secondary" disabled>End Session</button>
            <button id="startRecordBtn" class="btn btn-primary" disabled>Start Recording</button>
            <button id="stopRecordBtn" class="btn btn-secondary" disabled>Stop Recording</button>
            <button id="playRecordBtn" class="btn btn-primary" disabled>Play Recording</button>
            <button id="stopPlayBtn" class="btn btn-secondary" disabled>Stop Playback</button>
        </div>

        <!-- Information panel with three main sections -->
        <div class="info-panel">
            <!-- Session status and exercise counters -->
            <div class="info-card">
                <h3>Session Status</h3>
                <div id="sessionStatus" class="status inactive">Inactive</div>
                <p id="frameCount">Frames processed: 0</p>
                <div class="exercise-history-title">Exercise History</div>
                <div id="exerciseCounters">
                    <!-- Individual exercise counters -->
                    <p>Bench Press: <span id="bench_press_count">0</span></p>
                    <p>Squat: <span id="squat_count">0</span></p>
                    <p>Lat Machine: <span id="lat_machine_count">0</span></p>
                    <p>Pull Up: <span id="pull_up_count">0</span></p>
                    <p>Push Up: <span id="push_up_count">0</span></p>
                    <p>Split Squat: <span id="split_squat_count">0</span></p>
                </div>
            </div>

            <!-- Current exercise detection info -->
            <div class="info-card">
                <h3>Current Exercise</h3>
                <p id="currentExercise">None detected</p>
                <p id="confidence">Confidence: 0%</p>
            </div>

            <!-- Form analysis and feedback -->
            <div class="info-card">
                <h3>Form Analysis</h3>
                <div id="feedback" class="feedback neutral">Select a camera and press 'Start Session' to begin</div>
                <!-- Warning history with scrollable container -->
                <div id="warningHistory" style="margin-top: 10px; max-height: 150px; overflow-y: auto; font-size: 0.9em;">
                    <strong>Warning History:</strong>
                    <div id="warningList"></div>
                </div>
            </div>
        </div>
    </div>
<script>
        /**
         * ExerciseAnalyzer Class
         * Analyzes exercise form using MediaPipe pose detection and LSTM classification
         * Provides real-time feedback on exercise execution quality
         */
        class ExerciseAnalyzer {
             constructor() {
                // Get video and canvas elements from DOM
                this.video = document.getElementById('videoElement');
                this.canvas = document.getElementById('canvasElement');
                this.ctx = this.canvas.getContext('2d');
                
                // Exercise classes - must match those from the Python server
                this.classes = ["bench_press", "squat", "lat_machine", "pull_up", "push_up", "split_squat"];
                this.sequenceLength = 30; // Number of frames for LSTM classification
                this.keypointDim = 132; // 33 landmarks * 4 (x, y, z, visibility)
                
                // Application state variables
                this.sessionActive = false; 
                this.sequence = []; // Sequence of poses for LSTM model
                this.exerciseHistory = []; // History of detected exercises
                this.currentExercise = null; // Currently detected exercise
                this.frameCount = 0; // Total frames processed

                // Camera management variables
                this.selectedCameraId = null; 
                this.availableCameras = []; 
                this.currentStream = null; 

                // Warning management for persistent 3-second warnings
                this.activeWarning = null; 

                this.warningHistory = []; // History of all warnings

                // Text-to-speech synthesis setup
                this.speechSynthesis = window.speechSynthesis;
                this.lastWarningTime = 0; 
                this.warningCooldown = 3000; // 3 seconds cooldown between voice messages
                this.lastFeedbackColor = null; // Previous feedback color state
                this.warningStartTime = null; 
                this.warningTimeout = null; 

                // New properties for recording/playback functionality
                this.isRecording = false; 
                this.recordedPoses = []; // Array of recorded pose data
                this.isReplaying = false; // Whether currently replaying recorded poses
                this.replayIndex = 0; 
                this.replayInterval = null; 
                this.recordingStartTime = 0; 

                // Angle history for minimum detection in exercises
                // Maintains buffers for each exercise's relevant angles
                this.angleHistory = {
                    bench_press: { ang3: [], ang4: [] }, 
                    squat: { angleL: [], angleR: [] },  
                    lat_machine: { ang1: [], ang2: [] },
                    pull_up: { ang1: [], ang2: [] }, 
                    push_up: { ang5: [], ang6: [] }, 
                    split_squat: { angleL: [], angleR: [] }
                };
                this.historySize = 3; // Number of frames to maintain for minimum detection

                // Counters for correct exercise repetitions
                this.exerciseCounters = {
                    bench_press: 0,
                    squat: 0,
                    lat_machine: 0,
                    pull_up: 0,
                    push_up: 0,
                    split_squat: 0
                };

                // Timer to avoid multiple counts for same repetition
                this.lastFeedbackColor = null;
                
                // MediaPipe pose detection instance
                this.pose = null;
                this.isProcessing = false; // Whether currently processing frames
                this.animationId = null; // Animation frame ID for processing loop
                
                // Initialize application components
                this.initializeElements();
                this.setupCameraSelector();
                this.setupMediaPipe();
                
                // Handle window resize events
                this.handleResize = this.handleResize.bind(this);
                window.addEventListener('resize', this.handleResize);
            }

            /**
             * Plays a beep sound when exercise is performed correctly
             * Uses Web Audio API to generate a sine wave tone
             */
            playCorrectSound() {
                // Create audio context for sound generation
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                // Connect audio nodes
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // Configure sound properties
                oscillator.frequency.setValueAtTime(800, audioContext.currentTime); // 800Hz frequency
                oscillator.type = 'sine'; // Sine wave for clean sound
                
                // Set volume and fade out
                gainNode.gain.setValueAtTime(0.9, audioContext.currentTime); 
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3); 
                
                // Play sound for 300ms
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.3);
            }

            /**
             * Speaks warning text using text-to-speech
             * Implements cooldown to avoid too frequent voice messages
             */
            speakWarning(text) {
                const currentTime = Date.now();
                
                // Avoid too frequent voice messages
                if (currentTime - this.lastWarningTime < this.warningCooldown) {
                    return;
                }
                
                // Cancel any previous speech
                if (this.speechSynthesis.speaking) {
                    this.speechSynthesis.cancel();
                }
                
                // Configure speech utterance
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'en-US'; 
                utterance.rate = 1.0; 
                utterance.pitch = 1.0;
                utterance.volume = 0.8;
                
                // Speak the warning
                this.speechSynthesis.speak(utterance);
                this.lastWarningTime = currentTime;
            }

            /**
             * Starts recording pose data during an active session
             * Records poses with timestamps for later playback
             */
            startRecording() {
                // Ensure session is active before recording
                if (!this.sessionActive) {
                    this.showError('Please start a session first');
                    return;
                }
                
                // Initialize recording state
                this.isRecording = true;
                this.recordedPoses = [];
                this.recordingStartTime = Date.now();
                
                // Update UI button states
                document.getElementById('startRecordBtn').disabled = true;
                document.getElementById('stopRecordBtn').disabled = false;
                document.getElementById('playRecordBtn').disabled = true;
                
                // Show recording status
                this.updateFeedback('Recording poses...', 'warning');
                console.log('Started recording poses');
            }

            /**
             * Stops the current pose recording session
             * Updates UI and shows recording statistics
             */
            stopRecording() {
                this.isRecording = false;
                
                // Update UI button states
                document.getElementById('startRecordBtn').disabled = false;
                document.getElementById('stopRecordBtn').disabled = true;
                document.getElementById('playRecordBtn').disabled = false;
                
                // Show recording completion status
                this.updateFeedback(`Recording stopped. Captured ${this.recordedPoses.length} poses`, 'neutral');
                console.log(`Recording stopped. Total poses: ${this.recordedPoses.length}`);
            }

            /**
             * Plays back previously recorded poses
             * Replays poses at 30 FPS with progress feedback
             */
            playRecording() {
                // Check if there are recorded poses to play
                if (this.recordedPoses.length === 0) {
                    this.showError('No recorded poses to play');
                    return;
                }
                
                // Initialize playback state
                this.isReplaying = true;
                this.replayIndex = 0;
                
                // Update UI - disable other controls during playback
                document.getElementById('playRecordBtn').disabled = true;
                document.getElementById('stopPlayBtn').disabled = false;
                document.getElementById('startBtn').disabled = true;
                document.getElementById('endBtn').disabled = true;
                
                this.updateFeedback('Playing recorded poses...', 'correct');
                
                // Start playback at ~30 FPS 
                this.replayInterval = setInterval(() => {
                    // Check if we've reached the end of recorded poses
                    if (this.replayIndex >= this.recordedPoses.length) {
                        this.stopPlayback();
                        return;
                    }
                    
                    // Get current pose data and draw it
                    const poseData = this.recordedPoses[this.replayIndex];
                    this.drawRecordedPose(poseData.landmarks);
                    this.replayIndex++;
                    
                    // Update UI with playback progress
                    const progress = Math.round((this.replayIndex / this.recordedPoses.length) * 100);
                    this.updateFeedback(`Playing: ${progress}% (Frame ${this.replayIndex}/${this.recordedPoses.length})`, 'correct');
                    
                }, 33);
            }

            /**
             * Stops the current pose playback
             * Cleans up playback state and re-enables controls
             */
            stopPlayback() {
                this.isReplaying = false;
                
                // Clear the playback interval
                if (this.replayInterval) {
                    clearInterval(this.replayInterval);
                    this.replayInterval = null;
                }
                
                // Re-enable UI controls
                document.getElementById('playRecordBtn').disabled = false;
                document.getElementById('stopPlayBtn').disabled = true;
                document.getElementById('startBtn').disabled = false;
                document.getElementById('endBtn').disabled = false;
                
                // Clear the canvas and update feedback
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.updateFeedback('Playback stopped', 'neutral');
            }

           /**
             * Draws a recorded pose on the canvas during playback
             * Uses the same proportional calculations as live rendering
             */
            drawRecordedPose(landmarks) {
                // Clear the canvas before drawing the new pose
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // If there are no landmarks, exit the function
                if (!landmarks) return;
                
                // Calculate proportions to maintain video aspect ratio
                const videoAspect = this.video.videoWidth / this.video.videoHeight;
                const canvasAspect = this.canvas.width / this.canvas.height;
                
                let renderWidth, renderHeight, offsetX, offsetY;

                // Determine if the video is wider or taller than the canvas
                if (videoAspect > canvasAspect) {
                    // Video is wider: fit to canvas width
                    renderWidth = this.canvas.width;
                    renderHeight = renderWidth / videoAspect;
                    offsetX = 0;
                    offsetY = (this.canvas.height - renderHeight) / 2; // Center vertically
                } else {
                    // Video is taller: fit to canvas height
                    renderHeight = this.canvas.height;
                    renderWidth = renderHeight * videoAspect;
                    offsetX = (this.canvas.width - renderWidth) / 2; // Center horizontally
                    offsetY = 0;
                }
                this.ctx.save();
                
                // Apply transformations for:
                // 1. Translate to start point + width (for horizontal flip)
                // 2. Scale -1 on X axis (horizontal flip, mirror effect)
                this.ctx.translate(offsetX + renderWidth, offsetY);
                this.ctx.scale(-1, 1);

                // Calculate scale factor to adapt landmarks to rendered dimensions
                const scaleFactor = renderWidth / this.video.videoWidth;

                // Draw connections between landmarks (skeleton lines)
                // Use different colors to distinguish playback from live
                drawConnectors(this.ctx, landmarks, POSE_CONNECTIONS, {
                    color: '#00FFFF',
                    lineWidth: 4,
                    scale: scaleFactor
                });

                // Draw landmark points (joints)
                // Use magenta color to distinguish from live mode
                drawLandmarks(this.ctx, landmarks, {
                    color: '#FF00FF', 
                    lineWidth: 2,
                    scale: scaleFactor
                });
                
                this.ctx.restore();
            }

            /**
             * Initialize all event listeners for interface controls
             * Connect buttons to their respective control functions
             */
            initializeElements() {
                // Session control buttons
                document.getElementById('startBtn').addEventListener('click', () => this.startSession());
                document.getElementById('endBtn').addEventListener('click', () => this.endSession());
                
                // Camera selector
                document.getElementById('cameraSelect').addEventListener('change', (e) => this.selectCamera(e.target.value));
                
                // Recording control buttons
                document.getElementById('startRecordBtn').addEventListener('click', () => this.startRecording());
                document.getElementById('stopRecordBtn').addEventListener('click', () => this.stopRecording());
                
                // Playback control buttons
                document.getElementById('playRecordBtn').addEventListener('click', () => this.playRecording());
                document.getElementById('stopPlayBtn').addEventListener('click', () => this.stopPlayback());
            }

            /**
             * Camera selector configuration
             * Requests camera permissions, enumerates available devices and populates the dropdown
             */
            async setupCameraSelector() {
                try {
                    // Request temporary camera access to obtain permissions
                    const tempStream = await navigator.mediaDevices.getUserMedia({ video: true });
                    tempStream.getTracks().forEach(track => track.stop());
                    
                    // Enumerate all available media devices
                    const devices = await navigator.mediaDevices.enumerateDevices();
                
                    this.availableCameras = devices.filter(device => device.kind === 'videoinput');
                    
                    // Populate dropdown with found cameras
                    const select = document.getElementById('cameraSelect');
                    select.innerHTML = '<option value="">Select a camera</option>';
                    
                    this.availableCameras.forEach((device, index) => {
                        const option = document.createElement('option');
                        option.value = device.deviceId;
                        // Use device label or generic name if not available
                        option.textContent = device.label || `Camera ${index + 1}`;
                        select.appendChild(option);
                    });

                    // If cameras are available, automatically select the first one
                    if (this.availableCameras.length > 0) {
                        select.value = this.availableCameras[0].deviceId;
                        this.selectedCameraId = this.availableCameras[0].deviceId;
                        await this.initCamera(); // Initialize the first camera immediately
                    }
                } catch (error) {
                    console.error('Error setting up camera selector:', error);
                    this.showError('Unable to access cameras. Please grant camera permissions.');
                }
            }

            /**
             * Handles camera switching
             * Stops current session if active and initializes the new camera
             */
            async selectCamera(deviceId) {
                // If no valid device is selected, exit
                if (!deviceId) return;
                
                // Store the selected camera ID
                this.selectedCameraId = deviceId;
                
                // If there's an active session, end it before switching cameras
                if (this.sessionActive) {
                    this.endSession();
                }
                
                // Initialize the new camera
                await this.initCamera();
                console.log('Camera switched to:', deviceId);
            }

            /**
             * MediaPipe Pose initialization and configuration
             * Configures the pose detection model and its parameters
             */
            async setupMediaPipe() {
                try {
                    // Create a new instance of MediaPipe's Pose model
                    this.pose = new Pose({
                        // Define where to find model files (CDN)
                        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
                    });

                    // Configure model parameters
                    this.pose.setOptions({
                        modelComplexity: 2,          // Model complexity (0=lite, 1=full, 2=heavy)
                        smoothLandmarks: true,       // Enable landmark smoothing between frames
                        enableSegmentation: false,   
                        smoothSegmentation: false,   
                        minDetectionConfidence: 0.5, 
                        minTrackingConfidence: 0.5,  
                        staticImageMode: false       
                    });
                    
                    // Connect callback to process results
                    this.pose.onResults((results) => this.onResults(results));
                    console.log('MediaPipe initialized successfully');
                } catch (error) {
                    console.error('MediaPipe setup error:', error);
                    this.showError('MediaPipe initialization failed. Please refresh the page.');
                }
            }

            /**
             * Shows a temporary error message to the user
             * Creates a red overlay that automatically disappears after 5 seconds
             */
            showError(message) {
                // Create a div element for the error
                const errorDiv = document.createElement('div');
                
                // Apply inline CSS styles for a centered red overlay
                errorDiv.style.cssText = `
                    position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
                    background: #f44336; color: white; padding: 15px 20px;
                    border-radius: 5px; z-index: 1000; font-weight: bold;
                `;
                errorDiv.textContent = message;
                document.body.appendChild(errorDiv);
                
                // Automatically remove error after 5 seconds
                setTimeout(() => errorDiv.remove(), 5000);
            }

            /**
             * Handles window resizing
             * Adapts canvas dimensions to video dimensions when window size changes
             */
            handleResize() {
                // Check that video is loaded and has valid dimensions
                if (this.video && this.video.videoWidth) {
                    // Adapt canvas to current video dimensions in the interface
                    this.canvas.width = this.video.clientWidth;
                    this.canvas.height = this.video.clientHeight;
                }
            }

            /**
             * Initialize the selected camera
             * Configure video stream and start frame processing
             */
            async initCamera() {
                // Verify that a camera has been selected
                if (!this.selectedCameraId) {
                    this.showError('Please select a camera first');
                    return;
                }

                try {
                    // Stop existing stream if present to avoid conflicts
                    if (this.currentStream) {
                        this.currentStream.getTracks().forEach(track => track.stop());
                        this.currentStream = null;
                    }

                    // Define constraints for the camera (
                    const constraints = {
                        video: {
                            deviceId: { exact: this.selectedCameraId }, // Force use of selected camera
                            width: { ideal: 640 },   // Ideal resolution 
                            height: { ideal: 480 }
                        }
                    };

                    // Get stream from selected camera
                    this.currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                    this.video.srcObject = this.currentStream;
                    
                    // CANVAS DIMENSIONS CONFIGURATION
                    // Wait for video metadata to load to get actual dimensions
                    await new Promise((resolve) => {
                        this.video.addEventListener('loadedmetadata', () => {
                            // Fixed dimensions for stickman 
                            // These can be modified according to needs
                            const stickmanWidth = 640;
                            const stickmanHeight = 480;
                            
                            this.canvas.width = stickmanWidth;
                            this.canvas.height = stickmanHeight;
                            resolve();
                        }, { once: true }); // Event listener that activates only once
                    });

                    // Start video playback
                    this.video.play();
                    
                    // Enable processing and start frame processing loop
                    this.isProcessing = true;
                    this.animationId = requestAnimationFrame(() => this.processFrame());

                    console.log('Camera initialized successfully');
                } catch (error) {
                    console.error('Camera initialization error:', error);
                    this.showError('Failed to initialize camera. Please try a different camera.');
                }
            }

            /**
             * Main video frame processing loop
             * Sends each frame to MediaPipe for pose analysis
             * Uses requestAnimationFrame to synchronize with browser refresh rate
             */
            async processFrame() {
                // Check necessary conditions for processing
                if (!this.isProcessing || !this.pose || !this.video.videoWidth) {
                    if (this.isProcessing) {
                        this.animationId = requestAnimationFrame(() => this.processFrame());
                    }
                    return;
                }

                try {
                    // Send current video frame to MediaPipe for analysis
                    // This is asynchronous and the result will arrive via onResults()
                    await this.pose.send({ image: this.video });
                } catch (error) {
                    console.error('Frame processing error:', error);
                }

                // Schedule next frame if processing is still active
                // This creates a continuous loop synchronized with the browser
                if (this.isProcessing) {
                    this.animationId = requestAnimationFrame(() => this.processFrame());
                }
            }

            /**
             * Finds local minimum in angle buffer to detect the lowest point of movement
             * Used to determine when an exercise reaches its maximum range of motion
             */
            findLocalMinimum(angleBuffer, currentAngle, threshold = 3) {
                // Add current angle to the buffer for analysis
                angleBuffer.push(currentAngle);
                
                // Maintain buffer size by removing oldest value when limit exceeded
                if (angleBuffer.length > this.historySize) {
                    angleBuffer.shift(); 
                }
                
                // Need at least 3 values to identify a local minimum
                if (angleBuffer.length < 3) {
                    return { isMinimum: false, value: null };
                }
                
                // Check if the middle element is a local minimum
                const midIndex = Math.floor(angleBuffer.length / 2);
                const midValue = angleBuffer[midIndex];
                
                let isMinimum = true;
                
                // Verify that middle value is smaller than all other elements
                for (let i = 0; i < angleBuffer.length; i++) {
                    if (i !== midIndex && angleBuffer[i] <= midValue) {
                        isMinimum = false;
                        break;
                    }
                }
                
                return { 
                    isMinimum: isMinimum, 
                    value: isMinimum ? midValue : null 
                };
            }

            /**
             * Calculates angle between three points using dot product formula
             * Used to measure joint angles for exercise form analysis
             */
            calculateAngle(a, b, c) {
                // Calculate vectors from vertex to other two points
                const ba = [a[0] - b[0], a[1] - b[1]];
                const bc = [c[0] - b[0], c[1] - b[1]];
                
                // Calculate dot product of the two vectors
                const dotProduct = ba[0] * bc[0] + ba[1] * bc[1];
                
                // Calculate magnitudes of both vectors
                const magBA = Math.sqrt(ba[0] ** 2 + ba[1] ** 2);
                const magBC = Math.sqrt(bc[0] ** 2 + bc[1] ** 2);
                
                // Calculate cosine of angle using dot product formula
                // Add small epsilon to prevent division by zero
                const cosineAngle = dotProduct / (magBA * magBC + 1e-6);
                
                // Calculate angle using inverse cosine, clamping to valid range [-1, 1]
                const angle = Math.acos(Math.max(-1, Math.min(1, cosineAngle)));
                
                // Convert from radians to degrees
                return angle * (180 / Math.PI);
            }

            /**
             * Analyzes exercise form based on pose landmarks and exercise type
             * Provides real-time feedback on movement quality and technique
             */
            analyzeExercise(landmarks, exerciseId) {
                let feedback = "";
                let color = "neutral";
                
                try {
                    if (exerciseId === 0) { // Bench press analysis
                        // Extract relevant body landmarks for bench press
                        const lShoulder = [landmarks[12].x, landmarks[12].y];
                        const rShoulder = [landmarks[11].x, landmarks[11].y];
                        const lHip = [landmarks[24].x, landmarks[24].y];
                        const rHip = [landmarks[23].x, landmarks[23].y];
                        const lElbow = [landmarks[14].x, landmarks[14].y];
                        const rElbow = [landmarks[13].x, landmarks[13].y];
                        const lWrist = [landmarks[16].x, landmarks[16].y];
                        const rWrist = [landmarks[15].x, landmarks[15].y];
                        const lKnee = [landmarks[26].x, landmarks[26].y];
                        const rKnee = [landmarks[25].x, landmarks[25].y];

                        // Calculate key angles for form analysis
                        const ang1 = this.calculateAngle(lElbow, lShoulder, lHip);  // Left shoulder angle
                        const ang2 = this.calculateAngle(rElbow, rShoulder, rHip);  // Right shoulder angle
                        const ang3 = this.calculateAngle(lWrist, lElbow, lShoulder); // Left elbow angle
                        const ang4 = this.calculateAngle(rWrist, rElbow, rShoulder); // Right elbow angle
                        const ang5 = this.calculateAngle(lShoulder, lHip, lKnee);    // Left hip angle
                        const ang6 = this.calculateAngle(rShoulder, rHip, rKnee);   // Right hip angle
                        
                        // Track local minimums to detect full range of motion
                        const minimum3 = this.findLocalMinimum(this.angleHistory.bench_press.ang3, ang3);
                        const minimum4 = this.findLocalMinimum(this.angleHistory.bench_press.ang4, ang4);

                        // Define form validation conditions
                        const cond1 = ang1 <= 80 || ang2 <= 80;     // Shoulder position check
                        const cond2 = ang3 <= 80 || ang4 <= 80;     // Elbow bend check
                        const cond3 = (160 <= ang5 && ang5 <= 200) || (160 <= ang6 && ang6 <= 200); // Hip stability
                        const cond4 = minimum3.value <= 80 || minimum4.value <= 80; // Full range check

                        // Provide feedback based on form analysis
                        if (cond1 && cond2 && cond3) {
                            feedback = "Bench-press - Correct Execution!";
                            color = "correct";
                        } else if (!cond4 && (minimum3.value <= 170 || minimum4.value <= 170)) {
                            feedback = "Bend your arms more until they reach parallel!";
                            color = "warning";
                        }

                    } else if (exerciseId === 1) { // Squat analysis
                        // Extract relevant landmarks for squat
                        const hipR = [landmarks[24].x, landmarks[24].y];
                        const hipL = [landmarks[23].x, landmarks[23].y];
                        const kneeR = [landmarks[26].x, landmarks[26].y];
                        const kneeL = [landmarks[25].x, landmarks[25].y];
                        const toeR = [landmarks[32].x, landmarks[32].y];
                        const toeL = [landmarks[31].x, landmarks[31].y];
                        const ankleR = [landmarks[28].x, landmarks[28].y];
                        const ankleL = [landmarks[27].x, landmarks[27].y];

                        // Calculate knee angles for both legs
                        const angleL = this.calculateAngle(hipL, kneeL, ankleL);
                        const angleR = this.calculateAngle(hipR, kneeR, ankleR);

                        // Detect local minimums for full squat depth
                        const minimumL = this.findLocalMinimum(this.angleHistory.squat.angleL, angleL);
                        const minimumR = this.findLocalMinimum(this.angleHistory.squat.angleR, angleR);
                        
                        // Define squat form validation conditions
                        const cond1 = toeL[0] <= kneeL[0];  
                        const cond2 = toeR[0] <= kneeR[0];  
                        const cond3 = minimumL.value <= 97; 
                        const cond4 = minimumR.value <= 97; 
                        const cond5 = angleL <= 100;         
                        const cond6 = angleR <= 100;         

                        // Analyze squat form and provide feedback
                        if (cond1 && cond2 && (cond5 || cond6) && (toeL[0] <= hipL[0] && toeR[0] <= hipR[0])) {
                            feedback = "Squat - Correct Execution!";
                            color = "correct";
                        } else if ((!cond1 || !cond2)) {
                            feedback = "Knees further forward than the tip of the feet";
                            color = "warning";
                        } else if ((!cond3 || !cond4) && (minimumL.value <= 145 || minimumR.value <= 145) && (toeL[0] <= hipL[0] || toeR[0] <= hipR[0])) {
                            feedback = "Bend the leg more, until reaching parallel";
                            color = "warning";
                        } else if (cond5 && (toeL[0] >= hipL[0] && toeR[0] >= hipR[0])) {
                            feedback = "";
                            color = "neutral";
                        }

                    } else if (exerciseId === 2) { // Lat machine analysis
                        // Extract landmarks
                        const lShoulder = [landmarks[12].x, landmarks[12].y];
                        const rShoulder = [landmarks[11].x, landmarks[11].y];
                        const lHip = [landmarks[24].x, landmarks[24].y];
                        const rHip = [landmarks[23].x, landmarks[23].y];
                        const lElbow = [landmarks[14].x, landmarks[14].y];
                        const rElbow = [landmarks[13].x, landmarks[13].y];
                        const lWrist = [landmarks[16].x, landmarks[16].y];
                        const rWrist = [landmarks[15].x, landmarks[15].y];
                        const lKnee = [landmarks[26].x, landmarks[26].y];
                        const rKnee = [landmarks[25].x, landmarks[25].y];
                        const lLowhead = [landmarks[10].x, landmarks[10].y];
                        const rLowhead = [landmarks[9].x, landmarks[9].y];

                        // Calculate angles for lat machine form analysis
                        const ang1 = this.calculateAngle(lWrist, lElbow, lShoulder); 
                        const ang2 = this.calculateAngle(rWrist, rElbow, rShoulder); 
                        const ang3 = this.calculateAngle(lShoulder, lHip, lKnee);    
                        const ang4 = this.calculateAngle(rShoulder, rHip, rKnee);   
                        
                        // Track minimum angles for full range check
                        const minimum1 = this.findLocalMinimum(this.angleHistory.lat_machine.ang1, ang1);
                        const minimum2 = this.findLocalMinimum(this.angleHistory.lat_machine.ang2, ang2);

                        // Define lat machineform conditions
                        const cond1 = (lLowhead[1] < lWrist[1] && rLowhead[1] < rWrist[1] && 
                                    rLowhead[1] < lWrist[1] && lLowhead[1] < rWrist[1]); 
                        const cond2 = ang1 <= 95 || ang2 <= 95;   
                        const cond3 = (90 <= ang3 && ang3 <= 130) || (90 <= ang4 && ang4 <= 130); 
                        const cond4 = ang3 <= 90 || ang4 <= 90;   
                        const cond5 = ang3 >= 130 || ang4 >= 130; 
                        const cond6 = minimum1.value <= 90 || minimum2.value <= 90; 

                        // Provide lat machine feedback
                        if (cond1 && cond2 && cond3) {
                            feedback = "Lat machine - Correct Execution!";
                            color = "correct";
                        } else if (!cond6 && (minimum1.value <= 140 || minimum2.value <= 140)) {
                            feedback = "Bend your arms more to overcome the bar with your chin!";
                            color = "warning";
                        } else if (cond4) {
                            feedback = "Tilt your chest back!";
                            color = "warning";
                        } else if (cond5) {
                            feedback = "Tilt your chest forward!";
                            color = "warning";
                        }

                    } else if (exerciseId === 3) { // Pull up analysis
                        // Extract landmarks for pull-up 
                        const lShoulder = [landmarks[12].x, landmarks[12].y];
                        const rShoulder = [landmarks[11].x, landmarks[11].y];
                        const lHip = [landmarks[24].x, landmarks[24].y];
                        const rHip = [landmarks[23].x, landmarks[23].y];
                        const lElbow = [landmarks[14].x, landmarks[14].y];
                        const rElbow = [landmarks[13].x, landmarks[13].y];
                        const lWrist = [landmarks[16].x, landmarks[16].y];
                        const rWrist = [landmarks[15].x, landmarks[15].y];
                        const lKnee = [landmarks[26].x, landmarks[26].y];
                        const rKnee = [landmarks[25].x, landmarks[25].y];
                        const lLowhead = [landmarks[10].x, landmarks[10].y];
                        const rLowhead = [landmarks[9].x, landmarks[9].y];

                        // Calculate pull-up form angles
                        const ang1 = this.calculateAngle(lWrist, lElbow, lShoulder);
                        const ang2 = this.calculateAngle(rWrist, rElbow, rShoulder);
                        const ang3 = this.calculateAngle(lShoulder, lHip, lKnee);
                        const ang4 = this.calculateAngle(rShoulder, rHip, rKnee);
                        
                        // Track elbow angle minimums for range check
                        const minimum1 = this.findLocalMinimum(this.angleHistory.pull_up.ang1, ang1);
                        const minimum2 = this.findLocalMinimum(this.angleHistory.pull_up.ang2, ang2);

                        // Define pull-up form conditions
                        const cond1 = (lLowhead[1] < lWrist[1] && rLowhead[1] < rWrist[1] && 
                                    rLowhead[1] < lWrist[1] && lLowhead[1] < rWrist[1]); 
                        const cond2 = ang1 <= 95 || ang2 <= 95;     
                        const cond3 = (165 <= ang3) || (165 <= ang4);
                        const cond4 = minimum1.value <= 80 || minimum2.value <= 80; 

                        // Provide pull-up feedback
                        if (cond1 && cond2 && cond3) {
                            feedback = "Pull-up - Correct Execution!";
                            color = "correct";
                        } else if (!cond4 && !cond1 && (minimum1.value <= 160 || minimum2.value <= 160)) {
                            feedback = "Bend your arms more to overcome the bar with your chin!";
                            color = "warning";
                        } else if (!cond3) {
                            feedback = "Align the body!";
                            color = "warning";
                        }

                    } else if (exerciseId === 4) { // Push up analysis
                        // Extract landmarks for push-up
                        const lShoulder = [landmarks[12].x, landmarks[12].y];
                        const rShoulder = [landmarks[11].x, landmarks[11].y];
                        const lHip = [landmarks[24].x, landmarks[24].y];
                        const rHip = [landmarks[23].x, landmarks[23].y];
                        const lKnee = [landmarks[26].x, landmarks[26].y];
                        const rKnee = [landmarks[25].x, landmarks[25].y];
                        const lAnkle = [landmarks[28].x, landmarks[28].y];
                        const rAnkle = [landmarks[27].x, landmarks[27].y];
                        const lElbow = [landmarks[14].x, landmarks[14].y];
                        const rElbow = [landmarks[13].x, landmarks[13].y];
                        const lWrist = [landmarks[16].x, landmarks[16].y];
                        const rWrist = [landmarks[15].x, landmarks[15].y];

                        // Calculate push-up form angles
                        const ang1 = this.calculateAngle(lShoulder, lHip, lAnkle); 
                        const ang2 = this.calculateAngle(rShoulder, rHip, rAnkle); 
                        const ang3 = this.calculateAngle(lHip, lKnee, lAnkle);     
                        const ang4 = this.calculateAngle(rHip, rKnee, rAnkle);     
                        const ang5 = this.calculateAngle(lWrist, lElbow, lShoulder);
                        const ang6 = this.calculateAngle(rWrist, rElbow, rShoulder);
                        
                        // Track elbow minimums for depth check
                        const minimum5 = this.findLocalMinimum(this.angleHistory.push_up.ang5, ang5);
                        const minimum6 = this.findLocalMinimum(this.angleHistory.push_up.ang6, ang6);

                        // Define push-up form conditions
                        const cond1 = (170 <= ang1 && ang1 <= 190) || (170 <= ang2 && ang2 <= 190); 
                        const cond4 = ang1 <= 170 || ang2 <= 170;  
                        const cond5 = ang1 >= 190 || ang2 >= 190;  
                        const cond2 = (150 <= ang3 && ang3 <= 190) || (150 <= ang4 && ang4 <= 190); 
                        const cond3 = ang5 <= 90 || ang6 <= 90; 
                        const cond6 = minimum5.value <= 90 || minimum6.value <= 90; 

                        // Provide push-up feedback
                        if (cond1 && cond2 && cond3) {
                            feedback = "Push-up - Correct Execution!";
                            color = "correct";
                        } else if (cond4) {
                            feedback = "Raise your pelvis - Align the body!";
                            color = "warning";
                        } else if (cond5) {
                            feedback = "Lower your pelvis - Align the body!";
                            color = "warning";
                        } else if (!cond6 && (minimum5.value <= 170 || minimum6.value <= 170)) {
                            feedback = "Bend your arms more until they reach parallel!";
                            color = "warning";
                        }

                    } else if (exerciseId === 5) { // Split squat analysis
                        // Extract landmarks for split squat
                        const hipR = [landmarks[24].x, landmarks[24].y];
                        const hipL = [landmarks[23].x, landmarks[23].y];
                        const kneeR = [landmarks[26].x, landmarks[26].y];
                        const kneeL = [landmarks[25].x, landmarks[25].y];
                        const toeR = [landmarks[32].x, landmarks[32].y];
                        const toeL = [landmarks[31].x, landmarks[31].y];
                        const ankleR = [landmarks[28].x, landmarks[28].y];
                        const ankleL = [landmarks[27].x, landmarks[27].y];

                        // Calculate knee angles for both legs
                        const angleL = this.calculateAngle(hipL, kneeL, ankleL);
                        const angleR = this.calculateAngle(hipR, kneeR, ankleR);

                        // Detect local minimums for squat depth
                        const minimumL = this.findLocalMinimum(this.angleHistory.split_squat.angleL, angleL);
                        const minimumR = this.findLocalMinimum(this.angleHistory.split_squat.angleR, angleR);
                        
                        // Define split squat form conditions
                        const cond1 = toeL[0] <= kneeL[0];  
                        const cond2 = toeR[0] <= kneeR[0];  
                        const cond3 = minimumL.value <= 90; 
                        const cond4 = minimumR.value <= 90; 
                        const cond5 = angleL <= 90;         
                        const cond6 = angleR <= 90;         

                        // Determine which leg is forward and provide appropriate feedback
                        if (toeL[0] < toeR[0]) { // Left leg forward
                            if (cond1 && cond5 && (toeL[0] >= hipL[0] || toeR[0] >= hipR[0])) {
                                feedback = "Split squat left leg - Correct Execution!";
                                color = "correct";
                            } else if (!cond1 && cond5) {
                                feedback = "Left knee further forward than the tip of the foot";
                                color = "warning";
                            } else if (!cond3 && minimumL.value <= 150 && (toeL[0] >= hipL[0] || toeR[0] >= hipR[0])) {
                                feedback = "Bend the left leg more, until reaching parallel";
                                color = "warning";
                            } else if (cond5 && (toeL[0] <= hipL[0] && toeR[0] <= hipR[0])) {
                                feedback = "";
                                color = "neutral";
                            }
                        } else { // Right leg forward
                            if (cond2 && cond6 && (toeL[0] >= hipL[0] || toeR[0] >= hipR[0])) {
                                feedback = "Split squat right leg - Correct Execution!";
                                color = "correct";
                            } else if (!cond2 && cond6) {
                                feedback = "Right knee further forward than the tip of the foot";
                                color = "warning";
                            } else if (!cond4 && minimumR.value <= 140 && (toeL[0] >= hipL[0] || toeR[0] >= hipR[0])) {
                                feedback = "Bend the right leg more, until reaching parallel";
                                color = "warning";
                            } else if (cond6 && (toeL[0] <= hipL[0] && toeR[0] <= hipR[0])) {
                                feedback = "";
                                color = "neutral";
                            }
                        }
                    }

                    // PERSISTENT WARNING MANAGEMENT (3-second duration)
                    const currentTime = Date.now();
                    
                    // If calculated color is "correct", immediately cancel active warning
                    if (color === "correct") {
                        this.activeWarning = null;
                    }
                    // If we have a new warning, save it and set timer
                    else if (color === "warning" && feedback) {
                        this.activeWarning = {
                            message: feedback,
                            startTime: currentTime
                        };
                    }
                    // If we have an active warning, check if 3 seconds have passed
                    else if (this.activeWarning && color !== "correct") {
                        const timeSinceWarning = currentTime - this.activeWarning.startTime;
                        
                        if (timeSinceWarning < 3000) {
                            // Warning is still valid, keep it active
                            feedback = this.activeWarning.message;
                            color = "warning";
                        } else {
                            // 3 seconds have passed, remove active warning
                            this.activeWarning = null;
                        }
                    }

                    // Save warning to history if it's a new warning
                    if (color === "warning" && feedback) {
                        this.activeWarning = {
                            message: feedback,
                            startTime: currentTime
                        };
                        
                        // Save warning if:
                        // 1. It's the first warning ever, OR
                        // 2. Previous feedback was NOT a warning (new series), OR  
                        // 3. It's a different warning from the previous one
                        const shouldSave = this.warningHistory.length === 0 || 
                                        this.lastFeedbackColor !== "warning" ||
                                        this.warningHistory[this.warningHistory.length - 1].message !== feedback;
                        
                        if (shouldSave) {
                            this.warningHistory.push({
                                message: feedback,
                                timestamp: new Date().toLocaleTimeString(),
                                exercise: this.classes[exerciseId] || 'Unknown'
                            });
                            this.updateWarningHistory();
                        }
                    }

                    // Voice synthesis management 
                    if (color === "warning" && feedback) {
                        // If it's the first warning or a different warning, start timer
                        if (this.lastFeedbackColor !== "warning") {
                            this.warningStartTime = Date.now();
                            
                            // Clear any previous timeout
                            if (this.warningTimeout) {
                                clearTimeout(this.warningTimeout);
                            }
                            
                            // Set new timeout for voice synthesis
                            this.warningTimeout = setTimeout(() => {
                                this.speakWarning(feedback);
                                this.warningTimeout = null;
                            }, 0); // 0 milliseconds delay
                        }
                    } else {
                        // If there's no more warning, cancel timeout if present
                        if (this.warningTimeout) {
                            clearTimeout(this.warningTimeout);
                            this.warningTimeout = null;
                        }
                    }
                    
                } catch (error) {
                    console.error('Analysis error:', error);
                    feedback = "Analysis not available";
                    color = "neutral";
                }

                // Handle correct exercise completion
                if (color === "correct" && (this.lastFeedbackColor === "warning" || this.lastFeedbackColor === "neutral")) {
                    const exerciseName = this.classes[exerciseId];
                    this.exerciseCounters[exerciseName]++;
                    this.updateExerciseCounter(exerciseName);
                    this.playCorrectSound(); // Play sound only when exercise is performed correctly
                }
                
                // Update previous state
                this.lastFeedbackColor = color;

                return { feedback, color };
            }

            /**
             * Updates the warning history display in the UI
             * Shows the last 5 warnings with timestamp and exercise information
             */
            updateWarningHistory() {
                const warningList = document.getElementById('warningList');
                const last5Warnings = this.warningHistory.slice(-5); // Show only the last 5 warnings
                
                // Generate HTML for each warning with styling
                warningList.innerHTML = last5Warnings.map(warning => 
                    `<div style="padding: 2px 0; color: #ff6b35;">
                        <small>${warning.timestamp} - ${warning.exercise}:</small><br>
                        ${warning.message}
                    </div>`
                ).join('');
            }

            /*
             * Updates the exercise counter display for a specific exercise
             */
            updateExerciseCounter(exerciseName) {
                const countElement = document.getElementById(`${exerciseName}_count`);
                if (countElement) {
                    countElement.textContent = this.exerciseCounters[exerciseName];
                }
            }

            /**
             * Converts MediaPipe pose landmarks to array format required by the LSTM model
             * Each landmark contributes 4 values: x, y, z, visibility
             * Flattened array of 132 values (33 landmarks × 4 values each)
             */
            landmarksToArray(landmarks) {
                const keypoints = [];
                // Ensure exactly 33 landmarks as expected by the Python model
                for (let i = 0; i < 33; i++) {
                    if (i < landmarks.length) {
                        keypoints.push(landmarks[i].x);
                        keypoints.push(landmarks[i].y);
                        keypoints.push(landmarks[i].z || 0.0);
                        keypoints.push(landmarks[i].visibility || 1.0);
                    } else {
                        // Padding with zeros if landmarks are missing
                        keypoints.push(0.0, 0.0, 0.0, 0.0);
                    }
                }
                return keypoints;
            }

            /**
             * Classifies the current exercise using the LSTM model
             * Maintains a sequence of 30 frames for temporal analysis
             */
            async classifyExercise(landmarks) {
                try {
                    const landmarkArray = this.landmarksToArray(landmarks);
                    this.sequence.push(landmarkArray);
                    
                    // Maintain sequence length of 30 frames
                    if (this.sequence.length > this.sequenceLength) {
                        // After classification, keep only the last frame for efficiency
                        const lastFrame = this.sequence[this.sequence.length - 1];
                        this.sequence = [lastFrame];  // Reset with only the last frame
                    }
                    
                    // Perform classification when we have enough frames
                    if (this.sequence.length === this.sequenceLength) {
                        const response = await fetch('/classify', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({ sequence: this.sequence })
                        });
                        
                        if (response.ok) {
                            const result = await response.json();
                            return { exercise: result.exercise, confidence: result.confidence };
                        } else {
                            console.error('Classification request failed:', response.status);
                        }
                    }
                    return { exercise: null, confidence: 0 };
                } catch (error) {
                    console.error('Classification error:', error);
                    return { exercise: null, confidence: 0 };
                }
            }

            /**
             * Main callback function for MediaPipe pose detection results
             * Handles pose drawing, recording, classification, and quality analysis
             */
            onResults(results) {
                if (!this.isProcessing) return;

                // Clear canvas for new frame
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                if (results.poseLandmarks && this.sessionActive && !this.isReplaying) {
                    this.frameCount++;

                    // RECORDING - if active, store pose data with timestamp
                    if (this.isRecording) {
                        const timestamp = Date.now() - this.recordingStartTime;
                        this.recordedPoses.push({
                            timestamp: timestamp,
                            landmarks: JSON.parse(JSON.stringify(results.poseLandmarks))
                        });
                    }

                    // Calculate proportional dimensions maintaining aspect ratio
                    const videoAspect = this.video.videoWidth / this.video.videoHeight;
                    const canvasAspect = this.canvas.width / this.canvas.height;
                    
                    let renderWidth, renderHeight, offsetX, offsetY;

                    // Fit video to canvas while maintaining aspect ratio
                    if (videoAspect > canvasAspect) {
                        renderWidth = this.canvas.width;
                        renderHeight = renderWidth / videoAspect;
                        offsetX = 0;
                        offsetY = (this.canvas.height - renderHeight) / 2;
                    } else {
                        renderHeight = this.canvas.height;
                        renderWidth = renderHeight * videoAspect;
                        offsetX = (this.canvas.width - renderWidth) / 2;
                        offsetY = 0;
                    }

                    // Draw pose skeleton with mirrored effect
                    this.ctx.save();
                    this.ctx.translate(offsetX + renderWidth, offsetY);
                    this.ctx.scale(-1, 1);

                    const scaleFactor = renderWidth / this.video.videoWidth;

                    // Draw pose connections
                    drawConnectors(this.ctx, results.poseLandmarks, POSE_CONNECTIONS, {
                        color: '#00FF00',
                        lineWidth: 4,
                        scale: scaleFactor
                    });

                    // Draw pose landmarks
                    drawLandmarks(this.ctx, results.poseLandmarks, {
                        color: '#FF0000',
                        lineWidth: 2,
                        scale: scaleFactor
                    });
                    this.ctx.restore();

                    // QUALITY ANALYSIS - performed on every frame if we have a classification
                    if (this.currentExercise !== null) {
                        const analysis = this.analyzeExercise(results.poseLandmarks, this.currentExercise);
                        this.updateFeedback(analysis.feedback, analysis.color);
                    }

                    // CLASSIFICATION - performed every 30 frames 
                    this.classifyExercise(results.poseLandmarks).then(classification => {
                        if (classification.confidence > 0.9 && classification.exercise !== null) {
                            // Update current exercise classification
                            this.currentExercise = classification.exercise;
                            this.exerciseHistory.push(this.currentExercise);

                            // Display classification information
                            document.getElementById('currentExercise').textContent = this.classes[this.currentExercise];
                            document.getElementById('confidence').textContent = `Confidence: ${Math.round(classification.confidence * 100)}%`;
                        }
                    }).catch(error => {
                        console.error('Classification failed:', error);
                    });

                    // Update frame counter display
                    document.getElementById('frameCount').textContent = `Frames processed: ${this.frameCount}`;
                }
            }

            /**
             * Updates the feedback display with exercise analysis results
             */
            updateFeedback(text, colorClass) {
                const feedbackElement = document.getElementById('feedback');
                feedbackElement.textContent = text;
                feedbackElement.className = `feedback ${colorClass}`;
            }

            /**
             * Starts an exercise analysis session
             * Initializes camera, resets counters, and begins pose processing
             */
            async startSession() {
                if (!this.selectedCameraId) {
                    this.showError('Please select a camera first');
                    return;
                }

                // Ensure camera is initialized
                if (!this.currentStream) {
                    await this.initCamera();
                }

                if (!this.currentStream || !this.pose) {
                    this.showError('Camera or MediaPipe not ready. Please select a camera and try again.');
                    return;
                }

                // Initialize session state
                this.sessionActive = true;
                this.isProcessing = true;
                this.sequence = []; // Reset sequence for LSTM model
                this.exerciseHistory = [];
                
                // Reset exercise counters
                Object.keys(this.exerciseCounters).forEach(key => {
                    this.exerciseCounters[key] = 0;
                    this.updateExerciseCounter(key);
                });
                
                // Reset angle history for all exercises
                Object.keys(this.angleHistory).forEach(exercise => {
                    Object.keys(this.angleHistory[exercise]).forEach(angle => {
                        this.angleHistory[exercise][angle] = [];
                    });
                });
                
                // Reset feedback and warning states
                this.lastFeedbackColor = null;
                this.warningStartTime = null;
                if (this.warningTimeout) {
                    clearTimeout(this.warningTimeout);
                    this.warningTimeout = null;
                }
                
                // Reset counters and states
                this.frameCount = 0;
                this.currentExercise = null;
                this.warningHistory = []; // Clear warning history
                
                // Update UI elements
                document.getElementById('warningList').innerHTML = ''; // Clear warning display
                document.getElementById('startBtn').disabled = true;
                document.getElementById('endBtn').disabled = false;
                document.getElementById('cameraSelect').disabled = true;
                document.getElementById('sessionStatus').textContent = 'Active';
                document.getElementById('sessionStatus').className = 'status active';
                document.getElementById('startRecordBtn').disabled = false;
                this.updateFeedback('Collecting pose data...', 'neutral');
                
                // Start processing loop
                this.processFrame();
                
                console.log('Session started with camera:', this.selectedCameraId);
            }

            /**
             * Ends the current exercise analysis session
             * Stops all processing, recording, and playback activities
             */
            endSession() {
                this.sessionActive = false;
                this.isProcessing = false;
                
                // Stop recording if active
                if (this.isRecording) {
                    this.stopRecording();
                }
                
                // Stop playback if active  
                if (this.isReplaying) {
                    this.stopPlayback();
                }
                
                // Stop animation loop
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
                
                // Update UI elements
                document.getElementById('startBtn').disabled = false;
                document.getElementById('endBtn').disabled = true;
                document.getElementById('cameraSelect').disabled = false;
                document.getElementById('sessionStatus').textContent = 'Inactive';
                document.getElementById('sessionStatus').className = 'status inactive';
                
                this.updateFeedback('Session completed', 'neutral');
                
                console.log('Session ended');
            }
        }

            // Initialize the application when the page loads
            window.addEventListener('load', () => {
                new ExerciseAnalyzer();
            });
        </script>
</body>
</html>




























